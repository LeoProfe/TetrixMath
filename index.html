<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>TetriMath — Cálculo mental</title>
  <style>
    :root {
      --bg: #121218;
      --panel: #1c1c25;
      --grid: #2a2a37;
      --fall: #1e90ff;
      --bad: #888b93;
      --text: #eef0f4;
      --accent: #59d66b;
    }
    html, body { height: 100%; margin: 0; background: var(--bg); color: var(--text); font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; }
    .wrap { max-width: 1100px; margin: 0 auto; padding: 12px; }
    header { display: grid; gap: 8px; grid-template-columns: 1fr; margin-bottom: 10px; }
    .row { display: flex; flex-wrap: wrap; align-items: center; gap: 8px; }
    .card { background: var(--panel); border-radius: 16px; padding: 10px; box-shadow: 0 6px 24px rgba(0,0,0,.25); }
    .title { font-size: 1.4rem; font-weight: 700; letter-spacing: .3px; }

    select, input[type="number"], input[type="text"], button { 
      background: #0e0e14; color: var(--text); border: 1px solid #2b2b38; border-radius: 12px; padding: 10px 12px; font-size: 1rem;
    }
    button { cursor: pointer; }
    button.primary { background: #0f172a; border-color: #2b386b; }
    button:disabled { opacity: .6; cursor: not-allowed; }

    .layout { display: grid; grid-template-columns: 1fr 280px; gap: 12px; }
    @media (max-width: 900px){ .layout { grid-template-columns: 1fr; } }

    .canvas-card { position: relative; display: grid; place-items: center; }
    canvas { width: 100%; height: auto; image-rendering: pixelated; border-radius: 12px; background: #0c0c12; }

    .panel { position: sticky; top: 8px; align-self: start; }
    .stat { display: flex; justify-content: space-between; margin: 6px 0; font-size: .98rem; }
    .stat b { font-variant-numeric: tabular-nums; }

    .kbd { background: #0e1018; border: 1px solid #293047; padding: 2px 6px; border-radius: 6px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: .9rem; }

    .input-row { display: grid; grid-template-columns: 1fr auto; gap: 8px; }

    .toast { position: fixed; left: 50%; transform: translateX(-50%); bottom: 16px; background: #0e1018; border: 1px solid #2a2f44; padding: 10px 14px; border-radius: 12px; box-shadow: 0 6px 24px rgba(0,0,0,.45); font-size: .95rem; display: none; }
  </style>
</head>
<body>
  <div class="wrap">
    <header class="card">
      <div class="row">
        <div class="title">TetriMath — Cálculo mental tipo Tetris</div>
      </div>
      <div class="row">
        <label for="mode">Modo:</label>
        <select id="mode" title="Elige operaciones">
          <option value="+">Sumas</option>
          <option value="-">Restas</option>
          <option value="*">Multiplicación</option>
          <option value="/">División exacta</option>
          <option value="mix" selected>Mixto</option>
        </select>
        <button id="startBtn" class="primary">Iniciar</button>
        <button id="pauseBtn">Pausar</button>
        <button id="resetBtn">Reiniciar</button>
      </div>
      <div class="row" style="font-size:.95rem;opacity:.9">
        Escribe el <b>resultado</b> y presiona <span class="kbd">Enter</span> o el botón <b>Enviar</b> antes de que caiga.
        Cada <b>10 aciertos</b> se limpian los bloques malos. La velocidad sube por nivel.
      </div>
    </header>

    <div class="layout">
      <div class="card canvas-card">
        <canvas id="game" width="760" height="648" aria-label="Tablero de juego"></canvas>
      </div>

      <aside class="card panel">
        <div class="stat"><span>Modo</span><b id="statMode">—</b></div>
        <div class="stat"><span>Nivel</span><b id="statLevel">1</b></div>
        <div class="stat"><span>Puntaje</span><b id="statScore">0</b></div>
        <div class="stat"><span>Aciertos</span><b id="statCorrect">0</b></div>
        <div class="stat"><span>High Score</span><b id="statHigh">0</b></div>
        <hr style="border:0;border-top:1px solid #2a2a37;margin:10px 0"/>
        <div class="stat"><span>Operación</span><b id="statOp">—</b></div>
        <div class="input-row" style="margin-top:8px">
          <input id="answer" type="text" inputmode="numeric" pattern="[0-9]*" placeholder="Tu respuesta…"/>
          <button id="sendBtn" class="primary">Enviar</button>
        </div>
        <div style="margin-top:10px; font-size:.9rem; opacity:.9">
          Accesos rápidos: <span class="kbd">Enter</span> enviar, <span class="kbd">P</span> pausa.
        </div>
      </aside>
    </div>
  </div>

  <div class="toast" id="toast"></div>

<script>
(function(){
  // ---------- Utilidades ----------
  const rnd = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

  // ---------- Configuración ----------
  const GRID_W = 10, GRID_H = 18;
  const CELL = 36; // px por celda en el lienzo base (se escalará por CSS)
  const START_INTERVAL = 900, MIN_INTERVAL = 220, LEVEL_STEP_MS = 80;
  const LEVEL_EVERY_CORRECT = 8, CLEAN_EVERY_CORRECT = 10;

  const COLORS = {
    bg: '#0c0c12', grid: '#2a2a37', fall: '#1e90ff', bad: '#888b93', text: '#eef0f4'
  };

  // ---------- Estado ----------
  let mode = 'mix';
  let grid; // matriz GRID_H x GRID_W con null o true (bloque malo)
  let score, high, correct, level, interval, gameOver;
  let falling = null; // {a,b,op,ans,x,y}
  let lastFall = 0;
  let paused = false;

  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const statMode = document.getElementById('statMode');
  const statLevel = document.getElementById('statLevel');
  const statScore = document.getElementById('statScore');
  const statCorrect = document.getElementById('statCorrect');
  const statHigh = document.getElementById('statHigh');
  const statOp = document.getElementById('statOp');
  const ansInput = document.getElementById('answer');
  const sendBtn = document.getElementById('sendBtn');
  const toast = document.getElementById('toast');

  // ---------- Problemas ----------
  function makeProblem(opMode){
    let op = opMode === 'mix' ? ['+','-','*','/'][rnd(0,3)] : opMode;
    let a,b,ans;
    if(op === '+'){ a=rnd(0,99); b=rnd(0,99); ans=a+b; }
    else if(op === '-'){
      a=rnd(0,99); b=rnd(0,99); if(b>a){ const t=a; a=b; b=t; } ans=a-b;
    } else if(op === '*'){ a=rnd(1,12); b=rnd(1,12); ans=a*b; }
    else { // '/'
      b=rnd(1,12); ans=rnd(1,12); a=b*ans; // división exacta
    }
    return { a, b, op, ans, x: rnd(0, GRID_W-1), y: 0 };
  }

  // ---------- Juego ----------
  function reset(){
    grid = Array.from({length: GRID_H}, () => Array(GRID_W).fill(null));
    score = 0; correct = 0; level = 1; interval = START_INTERVAL; gameOver = false; paused = false;
    high = Number(localStorage.getItem('tetrimath_high')||'0')||0;
    falling = makeProblem(mode); lastFall = performance.now();
    ansInput.value = '';
    updateStats(); draw();
  }

  function updateStats(){
    statMode.textContent = (mode==='mix'?'Mixto':({'+' : 'Sumas','-':'Restas','*':'Multiplicación','/':'División'}[mode]));
    statLevel.textContent = level;
    statScore.textContent = score;
    statCorrect.textContent = correct;
    statHigh.textContent = high;
    statOp.textContent = formatOp(falling);
  }

  function formatOp(p){ if(!p) return '—'; const sym = { '+': '+', '-':'−', '*':'×', '/':'÷' }[p.op]; return `${p.a}${sym}${p.b}`; }

  function lockPiece(){
    if(falling.y >= 0 && falling.y < GRID_H && falling.x >= 0 && falling.x < GRID_W){
      grid[falling.y][falling.x] = true; // bloque malo
    }
    // game over si la fila 0 tiene algo
    if(grid[0].some(Boolean)) gameOver = true;
    spawn();
  }

  function spawn(){
    falling = makeProblem(mode);
    lastFall = performance.now();
    ansInput.value = '';
    updateStats();
  }

  function submit(){
    if(gameOver || paused) return;
    const val = parseInt(ansInput.value, 10);
    if(Number.isNaN(val)) { ping('Ingresa un número'); return; }
    if(val === falling.ans){
      const base = 10, bonus = (level-1)*2; score += base + bonus; correct += 1;
      if(correct % LEVEL_EVERY_CORRECT === 0){ level += 1; interval = Math.max(MIN_INTERVAL, interval - LEVEL_STEP_MS); }
      if(correct % CLEAN_EVERY_CORRECT === 0){ clearAllBad(); ping('¡Limpieza total!'); }
      if(score > high){ high = score; localStorage.setItem('tetrimath_high', String(high)); }
      spawn();
    }
    ansInput.value = '';
    updateStats();
  }

  function clearAllBad(){
    for(let y=0;y<GRID_H;y++) for(let x=0;x<GRID_W;x++) grid[y][x]=null;
  }

  function tick(now){
    if(!paused && !gameOver){
      if(now - lastFall >= interval){
        const ny = falling.y + 1;
        if(ny >= GRID_H || grid[ny][falling.x]){ lockPiece(); }
        else { falling.y = ny; lastFall = now; updateStats(); }
      }
    }
    draw();
    requestAnimationFrame(tick);
  }

  // ---------- Dibujo ----------
  function draw(){
    const W = canvas.width, H = canvas.height; // tamaño base fijo
    ctx.clearRect(0,0,W,H);

    // tablero a la izquierda, panel dibujado en HTML
    const boardX = 12, boardY = 12, boardW = GRID_W*CELL, boardH = GRID_H*CELL;

    // fondo tablero
    ctx.fillStyle = COLORS.bg; ctx.fillRect(boardX, boardY, boardW, boardH);

    // grid
    ctx.strokeStyle = COLORS.grid; ctx.lineWidth = 1;
    for(let y=0;y<=GRID_H;y++){
      const yy = boardY + y*CELL; ctx.beginPath(); ctx.moveTo(boardX, yy); ctx.lineTo(boardX+boardW, yy); ctx.stroke();
    }
    for(let x=0;x<=GRID_W;x++){
      const xx = boardX + x*CELL; ctx.beginPath(); ctx.moveTo(xx, boardY); ctx.lineTo(xx, boardY+boardH); ctx.stroke();
    }

    // bloques malos
    ctx.fillStyle = COLORS.bad;
    for(let y=0;y<GRID_H;y++){
      for(let x=0;x<GRID_W;x++){
        if(grid[y][x]){
          const rx = boardX + x*CELL + 1, ry = boardY + y*CELL + 1;
          ctx.fillRect(rx, ry, CELL-2, CELL-2);
        }
      }
    }

    // pieza cayendo
    if(falling){
      ctx.fillStyle = COLORS.fall;
      const rx = boardX + falling.x*CELL + 1, ry = boardY + falling.y*CELL + 1;
      ctx.fillRect(rx, ry, CELL-2, CELL-2);
      // operación
      ctx.fillStyle = COLORS.text; ctx.font = '20px system-ui, sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillText(formatOp(falling), rx + (CELL-2)/2, ry + (CELL-2)/2);
    }

    // game over overlay
    if(gameOver){
      ctx.fillStyle = 'rgba(12,12,18,.7)'; ctx.fillRect(boardX, boardY, boardW, boardH);
      ctx.fillStyle = '#ff6b6b'; ctx.font = 'bold 42px system-ui, sans-serif'; ctx.textAlign = 'center';
      ctx.fillText('GAME OVER', boardX + boardW/2, boardY + boardH/2 - 16);
      ctx.fillStyle = COLORS.text; ctx.font = '20px system-ui, sans-serif';
      ctx.fillText('Pulsa Reiniciar para jugar otra vez', boardX + boardW/2, boardY + boardH/2 + 20);
    }
  }

  // ---------- UI ----------
  function ping(msg){
    toast.textContent = msg; toast.style.display = 'block';
    clearTimeout(ping._t); ping._t = setTimeout(()=> toast.style.display='none', 1400);
  }

  function resizeCanvas(){
    // El lienzo tiene tamaño fijo interno; lo escalamos por CSS via width:100%.
    // Ajustamos el tamaño interno para nitidez en pantallas retina.
    const ratio = Math.min(window.devicePixelRatio || 1, 2);
    canvas.width = 12 + GRID_W*CELL + 12; // 12px margen izq + tablero + margen der
    canvas.height = 12 + GRID_H*CELL + 12;
    canvas.style.width = '100%';
    canvas.style.height = 'auto';
    // Escalamos internamente para alta densidad
    const w = canvas.width, h = canvas.height;
    canvas.width = Math.floor(w * ratio);
    canvas.height = Math.floor(h * ratio);
    ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
    draw();
  }

  // ---------- Eventos ----------
  document.getElementById('mode').addEventListener('change', e=>{ mode = e.target.value; statMode.textContent = e.target.options[e.target.selectedIndex].text; });
  document.getElementById('startBtn').addEventListener('click', ()=>{ reset(); ansInput.focus(); });
  document.getElementById('pauseBtn').addEventListener('click', ()=>{ if(!gameOver){ paused = !paused; ping(paused? 'Pausa' : 'Reanudar'); ansInput.focus(); }});
  document.getElementById('resetBtn').addEventListener('click', ()=>{ reset(); ansInput.focus(); });
  sendBtn.addEventListener('click', submit);
  ansInput.addEventListener('keydown', (ev)=>{ if(ev.key === 'Enter'){ ev.preventDefault(); submit(); } });
  window.addEventListener('keydown', (ev)=>{
    if(ev.key.toLowerCase() === 'p'){ if(!gameOver){ paused = !paused; ping(paused? 'Pausa' : 'Reanudar'); } }
  });
  window.addEventListener('resize', resizeCanvas);

  // ---------- Inicio ----------
  resizeCanvas();
  reset();
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>
