<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>TetriMath — Cálculo mental</title>
    <style>
        :root {
            --bg: #121218;
            --panel: #1c1c25;
            --grid: #2a2a37;
            --fall: #1e90ff;
            --bad: #888b93;
            --text: #eef0f4;
            --accent: #59d66b;
        }
        html, body { height: 100%; margin: 0; background: var(--bg); color: var(--text); font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; }
        .wrap { max-width: 1100px; margin: 0 auto; padding: 12px; }
        header { display: grid; gap: 8px; grid-template-columns: 1fr; margin-bottom: 10px; }
        .row { display: flex; flex-wrap: wrap; align-items: center; gap: 8px; }
        .card { background: var(--panel); border-radius: 16px; padding: 10px; box-shadow: 0 6px 24px rgba(0,0,0,.25); }
        .title { font-size: 1.4rem; font-weight: 700; letter-spacing: .3px; }

        select, input[type="number"], input[type="text"], button {
            background: #0e0e14; color: var(--text); border: 1px solid #2b2b38; border-radius: 12px; padding: 10px 12px; font-size: 1rem;
        }
        button { cursor: pointer; }
        button.primary { background: #0f172a; border-color: #2b386b; }
        button:disabled { opacity: .6; cursor: not-allowed; }

        .layout { display: grid; grid-template-columns: 1fr 280px; gap: 12px; max-width: 650px; margin: 0 auto; }
        @media (max-width: 900px){ .layout { grid-template-columns: 1fr; } }

        .canvas-card { position: relative; display: grid; place-items: center; }
        canvas { width: 100%; height: auto; image-rendering: pixelated; border-radius: 12px; background: #0c0c12; }

        .panel { position: sticky; top: 8px; align-self: start; }
        .stat { display: flex; justify-content: space-between; margin: 6px 0; font-size: .98rem; }
        .stat b { font-variant-numeric: tabular-nums; }

        .kbd { background: #0e1018; border: 1px solid #293047; padding: 2px 6px; border-radius: 6px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: .9rem; }

        .input-row { display: grid; grid-template-columns: 1fr auto; gap: 8px; }
        
        .controls-mobile { display: none; }
        @media (max-width: 600px) {
            .controls-mobile {
                display: flex;
                justify-content: space-around;
                width: 100%;
                margin-top: 10px;
            }
            .controls-mobile button {
                padding: 15px 25px;
                font-size: 1.2rem;
            }
            .panel {
                order: -1;
            }
        }

        .toast { position: fixed; left: 50%; transform: translateX(-50%); bottom: 16px; background: #0e1018; border: 1px solid #2a2f44; padding: 10px 14px; border-radius: 12px; box-shadow: 0 6px 24px rgba(0,0,0,.45); font-size: .95rem; display: none; }
    </style>
</head>
<body>
    <div class="wrap">
        <header class="card">
            <div class="row">
                <div class="title">TetriMath — Cálculo mental tipo Tetris</div>
            </div>
            <div class="row">
                <label for="mode">Modo:</label>
                <select id="mode" title="Elige operaciones">
                    <option value="+">Sumas</option>
                    <option value="-">Restas</option>
                    <option value="*">Multiplicación</option>
                    <option value="/">División exacta</option>
                    <option value="mix" selected>Mixto</option>
                </select>
                <button id="startBtn" class="primary">Iniciar</button>
                <button id="pauseBtn">Pausar</button>
                <button id="resetBtn">Reiniciar</button>
            </div>
            <div class="row" style="font-size:.95rem;opacity:.9">
                Escribe el <b>resultado</b> y presiona <span class="kbd">Enter</span> o el botón <b>Enviar</b> antes de que caiga.
                Por cada acierto, se elimina un bloque malo.
            </div>
        </header>

        <div class="layout">
            <div class="card canvas-card">
                <canvas id="game" width="760" height="648" aria-label="Tablero de juego"></canvas>
            </div>

            <aside class="panel">
                <div class="card stat-card" style="margin-bottom: 12px;">
                    <div class="stat"><span>Modo</span><b id="statMode">—</b></div>
                    <div class="stat"><span>Nivel</span><b id="statLevel">1</b></div>
                    <div class="stat"><span>Puntaje</span><b id="statScore">0</b></div>
                    <div class="stat"><span>Aciertos</span><b id="statCorrect">0</b></div>
                    <div class="stat"><span>High Score</span><b id="statHigh">0</b></div>
                </div>

                <div class="card input-card">
                    <div class="stat"><span>Operación</span><b id="statOp">—</b></div>
                    <div class="input-row" style="margin-top:8px">
                        <input id="answer" type="text" inputmode="numeric" pattern="[0-9]*" placeholder="Tu respuesta…"/>
                        <button id="sendBtn" class="primary">Enviar</button>
                    </div>
                </div>
                <div class="card" style="margin-top:12px; font-size:.9rem; opacity:.9">
                    <b>Controles:</b><br/>
                    <span class="kbd">←</span> <span class="kbd">→</span> Mover<br/>
                    <span class="kbd">↓</span> Caída suave<br/>
                    <span class="kbd">Espacio</span> Caída instantánea<br/>
                    <span class="kbd">Enter</span> Enviar respuesta<br/>
                    <span class="kbd">P</span> Pausa
                </div>
            </aside>
            <div class="controls-mobile">
                <button id="leftBtn" aria-label="Mover a la izquierda">←</button>
                <button id="rightBtn" aria-label="Mover a la derecha">→</button>
                <button id="softDropBtn" aria-label="Caída suave">↓</button>
                <button id="hardDropBtn" aria-label="Caída instantánea">Espacio</button>
            </div>
        </div>
    </div>

    <div class="toast" id="toast"></div>

<script>
(function(){
    // ---------- Utilidades ----------
    const rnd = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

    // ---------- Configuración ----------
    const GRID_W = 10, GRID_H = 18;
    const CELL = 36;
    const START_INTERVAL = 800, MIN_INTERVAL = 150, LEVEL_STEP_MS = 60;
    const LEVEL_EVERY_CORRECT = 6;
    const SOFT_DROP_SPEED = 50;
    
    const COLORS = {
        bg: '#0c0c12', grid: '#2a2a37', fall: '#1e90ff', bad: '#888b93', text: '#eef0f4',
        op: { '+': '#4c96d7', '-': '#e580a5', '*': '#78d46a', '/': '#f8c263' }
    };
    const SHAPES = [
        [[1, 1, 1, 1]], // I
        [[1, 1], [1, 1]], // O
        [[0, 1, 0], [1, 1, 1]], // T
        [[1, 0, 0], [1, 1, 1]], // L
        [[0, 0, 1], [1, 1, 1]], // J
        [[0, 1, 1], [1, 1, 0]], // S
        [[1, 1, 0], [0, 1, 1]], // Z
    ];

    // ---------- Estado ----------
    let mode = 'mix';
    let grid;
    let score, high, correct, level, interval, gameOver;
    let falling = null;
    let lastFall = 0;
    let paused = false;
    let isDropping = false;

    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const statMode = document.getElementById('statMode');
    const statLevel = document.getElementById('statLevel');
    const statScore = document.getElementById('statScore');
    const statCorrect = document.getElementById('statCorrect');
    const statHigh = document.getElementById('statHigh');
    const statOp = document.getElementById('statOp');
    const ansInput = document.getElementById('answer');
    const sendBtn = document.getElementById('sendBtn');
    const toast = document.getElementById('toast');
    const leftBtn = document.getElementById('leftBtn');
    const rightBtn = document.getElementById('rightBtn');
    const softDropBtn = document.getElementById('softDropBtn');
    const hardDropBtn = document.getElementById('hardDropBtn');


    // ---------- Problemas y piezas ----------
    function makeProblem(opMode){
        let op = opMode === 'mix' ? ['+','-','*','/'][rnd(0,3)] : opMode;
        let a,b,ans;
        if(op === '+'){ a=rnd(0,99); b=rnd(0,99); ans=a+b; }
        else if(op === '-'){
            a=rnd(0,99); b=rnd(0,99); if(b>a){ const t=a; a=b; b=t; } ans=a-b;
        } else if(op === '*'){ a=rnd(1,12); b=rnd(1,12); ans=a*b; }
        else {
            b=rnd(1,12); ans=rnd(1,12); a=b*ans;
        }
        const shape = SHAPES[rnd(0, SHAPES.length-1)];
        const x = rnd(0, GRID_W - shape[0].length);
        return { a, b, op, ans, x, y: 0, shape, rot: 0 };
    }

    // ---------- Lógica del juego ----------
    function reset(){
        grid = Array.from({length: GRID_H}, () => Array(GRID_W).fill(null));
        score = 0; correct = 0; level = 1; interval = START_INTERVAL; gameOver = false; paused = false;
        high = Number(localStorage.getItem('tetrimath_high')||'0')||0;
        falling = makeProblem(mode);
        lastFall = performance.now();
        ansInput.value = '';
        updateStats();
        draw();
    }

    function updateStats(){
        statMode.textContent = (mode==='mix'?'Mixto':({'+' : 'Sumas','-':'Restas','*':'Multiplicación','/':'División'}[mode]));
        statLevel.textContent = level;
        statScore.textContent = score;
        statCorrect.textContent = correct;
        statHigh.textContent = high;
        statOp.textContent = formatOp(falling);
    }

    function formatOp(p){ if(!p) return '—'; const sym = { '+': '+', '-': '−', '*': '×', '/': '÷' }[p.op]; return `${p.a}${sym}${p.b}`; }

    function lockPiece(){
        for (let r = 0; r < falling.shape.length; r++) {
            for (let c = 0; c < falling.shape[0].length; c++) {
                if (falling.shape[r][c]) {
                    const nx = falling.x + c;
                    const ny = falling.y + r;
                    if (ny >= 0 && ny < GRID_H && nx >= 0 && nx < GRID_W) {
                        grid[ny][nx] = { isBad: true, op: falling.op, value: formatOp(falling) };
                    }
                }
            }
        }
        if (grid[0].some(b => b?.isBad)) gameOver = true;
        spawn();
    }

    function spawn(){
        falling = makeProblem(mode);
        lastFall = performance.now();
        ansInput.value = '';
        if (!canMove(falling, falling.x, falling.y, falling.shape)) {
            gameOver = true;
            ping("¡Juego terminado!");
        }
        updateStats();
        draw();
    }

    function clearLastBadBlock(){
        for(let y = GRID_H - 1; y >= 0; y--){
            for(let x = GRID_W - 1; x >= 0; x--){
                if(grid[y][x]?.isBad){
                    grid[y][x] = null;
                    return;
                }
            }
        }
    }

    function submit(){
        if(gameOver || paused) return;
        const val = parseInt(ansInput.value, 10);
        if(Number.isNaN(val)) { ping('Ingresa un número'); return; }
        if(val === falling.ans){
            const base = 10, bonus = (level-1)*2; score += base + bonus; correct += 1;
            if(correct % LEVEL_EVERY_CORRECT === 0){ level += 1; interval = Math.max(MIN_INTERVAL, interval - LEVEL_STEP_MS); }
            clearLastBadBlock();
            ping("¡Correcto!");
            if(score > high){ high = score; localStorage.setItem('tetrimath_high', String(high)); }
            spawn();
        } else {
            lockPiece();
            ping("¡Incorrecto!");
        }
        ansInput.value = '';
        updateStats();
    }
    
    function canMove(piece, x, y, shape){
        shape = shape || piece.shape;
        for(let r=0; r < shape.length; r++) {
            for(let c=0; c < shape[0].length; c++) {
                if(shape[r][c]) {
                    const nx = x + c;
                    const ny = y + r;
                    if(nx < 0 || nx >= GRID_W || ny >= GRID_H) return false;
                    if(ny >= 0 && grid[ny][nx]) return false;
                }
            }
        }
        return true;
    }

    function move(dx){
        if(gameOver || paused) return;
        if(canMove(falling, falling.x + dx, falling.y)){
            falling.x += dx;
            draw();
        }
    }

    function dropOne(){
        if(gameOver || paused) return;
        if(canMove(falling, falling.x, falling.y + 1)){
            falling.y++;
        } else {
            lockPiece();
            return;
        }
    }

    function hardDrop(){
        if(gameOver || paused) return;
        while(canMove(falling, falling.x, falling.y + 1)){
            falling.y++;
        }
        lockPiece();
        draw();
    }

    function tick(now){
        if(!paused && !gameOver){
            const currentInterval = isDropping ? SOFT_DROP_SPEED : interval;
            if(now - lastFall >= currentInterval){
                dropOne();
                lastFall = now;
            }
        }
        draw();
        requestAnimationFrame(tick);
    }

    // ---------- Dibujo ----------
    function draw(){
        const W = canvas.width, H = canvas.height;
        ctx.clearRect(0,0,W,H);

        const boardX = 12, boardY = 12, boardW = GRID_W*CELL, boardH = GRID_H*CELL;

        ctx.fillStyle = COLORS.bg; ctx.fillRect(boardX, boardY, boardW, boardH);

        ctx.strokeStyle = COLORS.grid; ctx.lineWidth = 1;
        for(let y=0;y<=GRID_H;y++){
            const yy = boardY + y*CELL; ctx.beginPath(); ctx.moveTo(boardX, yy); ctx.lineTo(boardX+boardW, yy); ctx.stroke();
        }
        for(let x=0;x<=GRID_W;x++){
            const xx = boardX + x*CELL; ctx.beginPath(); ctx.moveTo(xx, boardY); ctx.lineTo(xx, boardY+boardH); ctx.stroke();
        }

        for(let y=0;y<GRID_H;y++){
            for(let x=0;x<GRID_W;x++){
                if(grid[y][x]?.isBad){
                    ctx.fillStyle = COLORS.op[grid[y][x].op] || COLORS.bad;
                    const rx = boardX + x*CELL + 1, ry = boardY + y*CELL + 1;
                    ctx.fillRect(rx, ry, CELL-2, CELL-2);
                    ctx.fillStyle = COLORS.text; ctx.font = '16px system-ui, sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.fillText(grid[y][x].value, rx + (CELL-2)/2, ry + (CELL-2)/2);
                }
            }
        }

        if(falling){
            let drawnOp = false;
            for(let r=0; r < falling.shape.length; r++) {
                for(let c=0; c < falling.shape[0].length; c++) {
                    if (falling.shape[r][c]) {
                        const nx = falling.x + c;
                        const ny = falling.y + r;
                        if(ny >= 0) {
                            ctx.fillStyle = COLORS.fall;
                            const rx = boardX + nx * CELL + 1;
                            const ry = boardY + ny * CELL + 1;
                            ctx.fillRect(rx, ry, CELL - 2, CELL - 2);

                            if (!drawnOp) {
                                ctx.fillStyle = COLORS.text;
                                ctx.font = '20px system-ui, sans-serif';
                                ctx.textAlign = 'center';
                                ctx.textBaseline = 'middle';
                                ctx.fillText(formatOp(falling), rx + (CELL-2)/2, ry + (CELL-2)/2);
                                drawnOp = true;
                            }
                        }
                    }
                }
            }
        }

        if(gameOver){
            ctx.fillStyle = 'rgba(12,12,18,.7)'; ctx.fillRect(boardX, boardY, boardW, boardH);
            ctx.fillStyle = '#ff6b6b'; ctx.font = 'bold 42px system-ui, sans-serif'; ctx.textAlign = 'center';
            ctx.fillText('FIN DEL JUEGO', boardX + boardW/2, boardY + boardH/2 - 16);
            ctx.fillStyle = COLORS.text; ctx.font = '20px system-ui, sans-serif';
            ctx.fillText('Pulsa Reiniciar para jugar otra vez', boardX + boardW/2, boardY + boardH/2 + 20);
        }
    }

    // ---------- UI y Eventos ----------
    function ping(msg){
        toast.textContent = msg; toast.style.display = 'block';
        clearTimeout(ping._t); ping._t = setTimeout(()=> toast.style.display='none', 1400);
    }

    function resizeCanvas(){
        const ratio = Math.min(window.devicePixelRatio || 1, 2);
        canvas.width = 12 + GRID_W*CELL + 12;
        canvas.height = 12 + GRID_H*CELL + 12;
        canvas.style.width = '100%';
        canvas.style.height = 'auto';
        const w = canvas.width, h = canvas.height;
        canvas.width = Math.floor(w * ratio);
        canvas.height = Math.floor(h * ratio);
        ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
        draw();
    }

    document.getElementById('mode').addEventListener('change', e=>{ mode = e.target.value; statMode.textContent = e.target.options[e.target.selectedIndex].text; });
    document.getElementById('startBtn').addEventListener('click', ()=>{ reset(); ansInput.focus(); });
    document.getElementById('pauseBtn').addEventListener('click', ()=>{ if(!gameOver){ paused = !paused; ping(paused? 'Pausa' : 'Reanudar'); ansInput.focus(); }});
    document.getElementById('resetBtn').addEventListener('click', ()=>{ reset(); ansInput.focus(); });
    sendBtn.addEventListener('click', submit);
    ansInput.addEventListener('keydown', (ev)=>{ if(ev.key === 'Enter'){ ev.preventDefault(); submit(); } });
    
    window.addEventListener('keydown', (ev)=>{
        if(ev.key.toLowerCase() === 'p'){ if(!gameOver){ paused = !paused; ping(paused? 'Pausa' : 'Reanudar'); } }
        if(gameOver || paused) return;
        if(ev.key === 'ArrowLeft'){ move(-1); }
        else if(ev.key === 'ArrowRight'){ move(1); }
        else if(ev.key === 'ArrowDown'){ isDropping = true; }
        else if(ev.key === ' '){ hardDrop(); }
    });
    window.addEventListener('keyup', (ev)=>{
        if(ev.key === 'ArrowDown'){ isDropping = false; }
    });

    leftBtn.addEventListener('click', () => move(-1));
    rightBtn.addEventListener('click', () => move(1));
    softDropBtn.addEventListener('touchstart', () => { isDropping = true; });
    softDropBtn.addEventListener('touchend', () => { isDropping = false; });
    hardDropBtn.addEventListener('click', () => hardDrop());


    window.addEventListener('resize', resizeCanvas);

    resizeCanvas();
    reset();
    requestAnimationFrame(tick);
})();
</script>
</body>
</html>
